{"id":"modules/interconnectionChart.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1742042086953},{"name":"d3","loc":{"line":4,"column":20,"index":94},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\src\\modules\\interconnectionChart.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.initializeInterconnectionChart = initializeInterconnectionChart;\nexports.updateInterconnectionChart = updateInterconnectionChart;\nvar d3 = _interopRequireWildcard(require(\"d3\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; } /**\n * Module for the advanced category interconnection visualization\n */\n/**\n * Initialize the categories interconnection chart\n * @returns {Object} The chart reference\n */\nfunction initializeInterconnectionChart() {\n  var container = d3.select('#interconnection-chart');\n\n  // Set up dimensions and margins\n  var margin = {\n    top: 40,\n    right: 40,\n    bottom: 40,\n    left: 40\n  };\n  var containerWidth = document.getElementById('interconnection-chart').clientWidth || 500;\n  var containerHeight = 300;\n  var width = Math.max(containerWidth - margin.left - margin.right, 100);\n  var height = containerHeight - margin.top - margin.bottom;\n\n  // Create SVG\n  var svg = container.append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', \"translate(\".concat(width / 2 + margin.left, \",\").concat(height / 2 + margin.top, \")\"));\n\n  // Add placeholder text\n  svg.append('text').attr('class', 'placeholder-text').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').style('font-size', '14px').style('fill', '#666').text('Loading interconnection visualization...');\n  return svg;\n}\n\n/**\n * Update the categories interconnection chart\n * This creates an interactive radial bubble visualization showing how categories interconnect\n * @param {Object} chart The chart reference\n * @param {Array} data Filtered data array\n */\nfunction updateInterconnectionChart(chart, data) {\n  // Clear existing content\n  chart.selectAll('*').remove();\n  if (data.length === 0) {\n    chart.append('text').attr('class', 'no-data-message').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').style('font-size', '14px').style('fill', '#666').text('No data available for the selected filters');\n    return;\n  }\n\n  // Extract unique corruption and health categories\n  var corruptionCategories = new Set();\n  var healthCategories = new Set();\n  data.forEach(function (item) {\n    if (Array.isArray(item['Corruption Categories'])) {\n      item['Corruption Categories'].forEach(function (cat) {\n        if (cat && cat.trim()) corruptionCategories.add(cat);\n      });\n    }\n    if (Array.isArray(item['Sector Categories'])) {\n      item['Sector Categories'].forEach(function (cat) {\n        if (cat && cat.trim()) healthCategories.add(cat);\n      });\n    }\n  });\n\n  // Convert to arrays and get top categories\n  var getTopCategories = function getTopCategories(categorySet, data, categoryType) {\n    var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n    var counts = {};\n    Array.from(categorySet).forEach(function (cat) {\n      counts[cat] = 0;\n      data.forEach(function (item) {\n        if (Array.isArray(item[categoryType]) && item[categoryType].includes(cat)) {\n          counts[cat]++;\n        }\n      });\n    });\n    return Object.entries(counts).sort(function (a, b) {\n      return b[1] - a[1];\n    }).slice(0, limit).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        count = _ref2[1];\n      return {\n        name: name,\n        count: count,\n        type: categoryType\n      };\n    });\n  };\n  var topIntegrityCategories = getTopCategories(corruptionCategories, data, 'Corruption Categories', 5);\n  var topHealthCategories = getTopCategories(healthCategories, data, 'Sector Categories', 5);\n\n  // Create nodes and connections for visualization\n  var nodes = [];\n  var links = [];\n\n  // Create connections (links) matrix between corruption and health categories\n  topIntegrityCategories.forEach(function (integrity) {\n    topHealthCategories.forEach(function (health) {\n      var coOccurrenceCount = 0;\n\n      // Count co-occurrences in articles\n      data.forEach(function (item) {\n        var hasIntegrity = Array.isArray(item['Corruption Categories']) && item['Corruption Categories'].includes(integrity.name);\n        var hasHealth = Array.isArray(item['Sector Categories']) && item['Sector Categories'].includes(health.name);\n        if (hasIntegrity && hasHealth) {\n          coOccurrenceCount++;\n        }\n      });\n      if (coOccurrenceCount > 0) {\n        links.push({\n          source: integrity.name,\n          target: health.name,\n          value: coOccurrenceCount\n        });\n      }\n    });\n    nodes.push({\n      id: integrity.name,\n      group: 'integrity',\n      count: integrity.count\n    });\n  });\n  topHealthCategories.forEach(function (health) {\n    nodes.push({\n      id: health.name,\n      group: 'health',\n      count: health.count\n    });\n  });\n\n  // If no connections found, show message\n  if (links.length === 0) {\n    chart.append('text').attr('class', 'no-data-message').attr('x', 0).attr('y', 0).attr('text-anchor', 'middle').style('font-size', '14px').style('fill', '#666').text('No category connections found in the selected data');\n    return;\n  }\n\n  // Get dimensions\n  var containerWidth = document.getElementById('interconnection-chart').clientWidth || 600;\n  var containerHeight = 300;\n  var width = containerWidth;\n  var height = containerHeight;\n\n  // Create a radial layout\n  var radius = Math.min(width, height) * 0.4;\n\n  // Define color scale for nodes\n  var color = d3.scaleOrdinal().domain(['integrity', 'health']).range(['#3694d1', '#e5007d']);\n\n  // Define node size scale\n  var nodeSize = d3.scaleLinear().domain([0, d3.max(nodes, function (d) {\n    return d.count;\n  })]).range([5, 15]);\n\n  // Define link width scale\n  var linkWidth = d3.scaleLinear().domain([0, d3.max(links, function (d) {\n    return d.value;\n  })]).range([1, 5]);\n\n  // Create force simulation for node placement\n  var simulation = d3.forceSimulation(nodes).force('link', d3.forceLink(links).id(function (d) {\n    return d.id;\n  }).distance(radius * 0.7)).force('charge', d3.forceManyBody().strength(-50)).force('center', d3.forceCenter(0, 0)).force('collide', d3.forceCollide().radius(function (d) {\n    return nodeSize(d.count) + 5;\n  }));\n\n  // Add center circle as guide\n  chart.append('circle').attr('r', radius).style('fill', 'none').style('stroke', '#eee').style('stroke-width', 1).style('stroke-dasharray', '3,3');\n\n  // Create links with gradients for better visual effect\n  var link = chart.append('g').attr('class', 'links').selectAll('path').data(links).enter().append('path').attr('class', 'link').style('stroke', function (d) {\n    // Create unique gradient ID\n    var gradientId = \"link-gradient-\".concat(d.source.id.replace(/\\s+/g, '-'), \"-\").concat(d.target.id.replace(/\\s+/g, '-'));\n\n    // Define gradient\n    var gradient = chart.append('defs').append('linearGradient').attr('id', gradientId).attr('gradientUnits', 'userSpaceOnUse');\n\n    // Add gradient stops\n    gradient.append('stop').attr('offset', '0%').attr('stop-color', color('integrity'));\n    gradient.append('stop').attr('offset', '100%').attr('stop-color', color('health'));\n    return \"url(#\".concat(gradientId, \")\");\n  }).style('stroke-width', function (d) {\n    return linkWidth(d.value);\n  }).style('stroke-opacity', 0.6).style('fill', 'none');\n\n  // Create nodes\n  var node = chart.append('g').attr('class', 'nodes').selectAll('g').data(nodes).enter().append('g').attr('class', 'node');\n\n  // Add circles to nodes\n  node.append('circle').attr('r', function (d) {\n    return nodeSize(d.count);\n  }).attr('fill', function (d) {\n    return color(d.group);\n  }).style('stroke', '#fff').style('stroke-width', 1.5).style('cursor', 'pointer').on('mouseover', function (d) {\n    // Highlight connected links and nodes\n    var connectedNodeIds = links.filter(function (link) {\n      return link.source.id === d.id || link.target.id === d.id;\n    }).map(function (link) {\n      return link.source.id === d.id ? link.target.id : link.source.id;\n    });\n    d3.selectAll('.link').style('stroke-opacity', function (l) {\n      return l.source.id === d.id || l.target.id === d.id ? 1 : 0.1;\n    });\n    d3.selectAll('.node circle').style('opacity', function (n) {\n      return n.id === d.id || connectedNodeIds.includes(n.id) ? 1 : 0.2;\n    });\n    d3.selectAll('.node text').style('opacity', function (n) {\n      return n.id === d.id || connectedNodeIds.includes(n.id) ? 1 : 0.2;\n    });\n\n    // Show tooltip\n    var tooltip = d3.select('#interconnection-chart').append('div').attr('class', 'chart-tooltip').style('position', 'absolute').style('left', \"\".concat(d3.event.pageX - d3.select('#interconnection-chart').node().getBoundingClientRect().left, \"px\")).style('top', \"\".concat(d3.event.pageY - d3.select('#interconnection-chart').node().getBoundingClientRect().top - 40, \"px\"));\n    var connectionCount = links.filter(function (link) {\n      return link.source.id === d.id || link.target.id === d.id;\n    }).length;\n    tooltip.html(\"\\n                <div class=\\\"chart-tooltip-title\\\">\".concat(d.id, \"</div>\\n                <div><span class=\\\"chart-tooltip-value\\\">\").concat(d.count, \"</span> articles</div>\\n                <div>Connected to \").concat(connectionCount, \" \").concat(d.group === 'integrity' ? 'health' : 'integrity', \" categories</div>\\n            \"));\n  }).on('mouseout', function () {\n    // Restore all elements\n    d3.selectAll('.link').style('stroke-opacity', 0.6);\n    d3.selectAll('.node circle').style('opacity', 1);\n    d3.selectAll('.node text').style('opacity', 1);\n\n    // Remove tooltip\n    d3.selectAll('.chart-tooltip').remove();\n  });\n\n  // Add labels to nodes\n  node.append('text').text(function (d) {\n    return d.id.length > 15 ? d.id.substring(0, 12) + '...' : d.id;\n  }).attr('dy', function (d) {\n    return nodeSize(d.count) + 12;\n  }).style('text-anchor', 'middle').style('font-size', '10px').style('fill', function (d) {\n    return d3.rgb(color(d.group)).darker();\n  }).style('pointer-events', 'none').style('font-weight', 'bold');\n\n  // Add highlight circles to highlight category types\n  chart.append('text').attr('x', -radius - 30).attr('y', -radius + 15).text('Integrity Categories').style('font-size', '11px').style('fill', color('integrity')).style('font-weight', 'bold');\n  chart.append('text').attr('x', radius - 50).attr('y', -radius + 15).text('Health Categories').style('font-size', '11px').style('fill', color('health')).style('font-weight', 'bold');\n\n  // Add animation for links\n  link.attr('stroke-dasharray', function () {\n    var length = this.getTotalLength();\n    return \"\".concat(length, \" \").concat(length);\n  }).attr('stroke-dashoffset', function () {\n    return this.getTotalLength();\n  }).transition().duration(1000).ease(d3.easeLinear).attr('stroke-dashoffset', 0);\n\n  // Initial animation for nodes\n  node.attr('opacity', 0).transition().delay(function (d, i) {\n    return i * 50;\n  }).duration(500).attr('opacity', 1);\n\n  // Update position function for simulation\n  simulation.on('tick', function () {\n    // Position nodes in a radial layout\n    nodes.forEach(function (node) {\n      if (node.group === 'integrity') {\n        // Position integrity categories on the left side\n        var angle = Math.PI + Math.random() * Math.PI - Math.PI / 2;\n        node.x = Math.cos(angle) * radius * 0.8;\n        node.y = Math.sin(angle) * radius * 0.8;\n      } else {\n        // Position health categories on the right side\n        var _angle = Math.random() * Math.PI - Math.PI / 2;\n        node.x = Math.cos(_angle) * radius * 0.8;\n        node.y = Math.sin(_angle) * radius * 0.8;\n      }\n    });\n\n    // Update link paths\n    link.attr('d', function (d) {\n      var dx = d.target.x - d.source.x;\n      var dy = d.target.y - d.source.y;\n      var dr = Math.sqrt(dx * dx + dy * dy) * 1.5; // Adjust curve\n      return \"M\".concat(d.source.x, \",\").concat(d.source.y, \"A\").concat(dr, \",\").concat(dr, \" 0 0,1 \").concat(d.target.x, \",\").concat(d.target.y);\n    });\n\n    // Update node positions\n    node.attr('transform', function (d) {\n      return \"translate(\".concat(d.x, \",\").concat(d.y, \")\");\n    });\n  });\n\n  // Run simulation for a short time then stop\n  simulation.alpha(1).restart();\n  setTimeout(function () {\n    return simulation.stop();\n  }, 2000);\n}\nvar _default = exports.default = {\n  initializeInterconnectionChart: initializeInterconnectionChart,\n  updateInterconnectionChart: updateInterconnectionChart\n};"},"sourceMaps":null,"error":null,"hash":"d13b42d13b684642284e4e74bad754a5","cacheData":{"env":{}}}