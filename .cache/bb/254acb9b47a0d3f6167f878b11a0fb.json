{"id":"../node_modules/d3-geo/src/clip/circle.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1741868822789},{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\package.json","includedInParent":true,"mtime":1737120275660},{"name":"../cartesian.js","loc":{"line":1,"column":102,"index":102},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\circle.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\cartesian.js"},{"name":"../circle.js","loc":{"line":2,"column":27,"index":149},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\circle.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\circle.js"},{"name":"../math.js","loc":{"line":3,"column":51,"index":217},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\circle.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\math.js"},{"name":"../pointEqual.js","loc":{"line":4,"column":23,"index":255},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\circle.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\pointEqual.js"},{"name":"./index.js","loc":{"line":5,"column":17,"index":293},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\circle.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _cartesian = require(\"../cartesian.js\");\nvar _circle = require(\"../circle.js\");\nvar _math = require(\"../math.js\");\nvar _pointEqual = _interopRequireDefault(require(\"../pointEqual.js\"));\nvar _index = _interopRequireDefault(require(\"./index.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _default(radius) {\n  var cr = (0, _math.cos)(radius),\n    delta = 6 * _math.radians,\n    smallRadius = cr > 0,\n    notHemisphere = (0, _math.abs)(cr) > _math.epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    (0, _circle.circleStream)(stream, radius, delta, direction, from, to);\n  }\n  function visible(lambda, phi) {\n    return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0,\n      // previous point\n      c0,\n      // code for previous point\n      v0,\n      // visibility of previous point\n      v00,\n      // visibility of first point\n      clean; // no intersections\n    return {\n      lineStart: function () {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function (lambda, phi) {\n        var point1 = [lambda, phi],\n          point2,\n          v = visible(lambda, phi),\n          c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || (0, _pointEqual.default)(point0, point2) || (0, _pointEqual.default)(point1, point2)) {\n            point1[0] += _math.epsilon;\n            point1[1] += _math.epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !(0, _pointEqual.default)(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function () {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function () {\n        return clean | (v00 && v0) << 1;\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = (0, _cartesian.cartesian)(a),\n      pb = (0, _cartesian.cartesian)(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 тип n2).\n    var n1 = [1, 0, 0],\n      // normal\n      n2 = (0, _cartesian.cartesianCross)(pa, pb),\n      n2n2 = (0, _cartesian.cartesianDot)(n2, n2),\n      n1n2 = n2[0],\n      // cartesianDot(n1, n2),\n      determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n    var c1 = cr * n2n2 / determinant,\n      c2 = -cr * n1n2 / determinant,\n      n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),\n      A = (0, _cartesian.cartesianScale)(n1, c1),\n      B = (0, _cartesian.cartesianScale)(n2, c2);\n    (0, _cartesian.cartesianAddInPlace)(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n      w = (0, _cartesian.cartesianDot)(A, u),\n      uu = (0, _cartesian.cartesianDot)(u, u),\n      t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1);\n    if (t2 < 0) return;\n    var t = (0, _math.sqrt)(t2),\n      q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);\n    (0, _cartesian.cartesianAddInPlace)(q, A);\n    q = (0, _cartesian.spherical)(q);\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n      lambda1 = b[0],\n      phi0 = a[1],\n      phi1 = b[1],\n      z;\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n    var delta = lambda1 - lambda0,\n      polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,\n      meridian = polar || delta < _math.epsilon;\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);\n      (0, _cartesian.cartesianAddInPlace)(q1, A);\n      return [q, (0, _cartesian.spherical)(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : _math.pi - radius,\n      code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n  return (0, _index.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi]);\n}"},"sourceMaps":null,"error":null,"hash":"0006df5062a148d99812abc2bc7d9501","cacheData":{"env":{}}}