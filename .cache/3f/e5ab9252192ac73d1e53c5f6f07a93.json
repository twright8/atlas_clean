{"id":"modules/map.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1742042086953},{"name":"./constants","loc":{"line":1,"column":43,"index":43},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\src\\modules\\map.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\src\\modules\\constants.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addMarkers = addMarkers;\nexports.clearMarkers = clearMarkers;\nexports.createMarker = createMarker;\nexports.default = void 0;\nexports.fitMapToBounds = fitMapToBounds;\nexports.getMapBounds = getMapBounds;\nexports.getMarkerIcon = getMarkerIcon;\nexports.initializeMap = initializeMap;\nexports.isMapMoving = isMapMoving;\nexports.onMoveEnd = void 0;\nexports.toggleLegend = toggleLegend;\nvar _constants = require(\"./constants\");\n// Map state\nvar map;\nvar currentLayer;\nvar markers;\nvar legend;\nvar legendAdded = false;\nvar consecutiveErrors = 0;\nvar maxConsecutiveErrors = 5;\n\n/**\n * Initialize the map with the base layer and configuration\n * @returns {Object} The map instance and related objects\n */\nfunction initializeMap() {\n  console.time('Map Initialization');\n\n  // Initialize map centered at [0, 0] with zoom level 2\n  map = L.map('map', {\n    maxZoom: 18,\n    minZoom: 2,\n    zoomAnimation: true,\n    fadeAnimation: true,\n    markerZoomAnimation: true,\n    zoomSnap: 0.5,\n    zoomDelta: 0.5,\n    wheelPxPerZoomLevel: 120\n  }).setView([0, 0], 2);\n\n  // Make map instance available globally\n  window.map = map;\n\n  // Create marker cluster group for better performance with many markers\n  try {\n    // Try to create a MarkerClusterGroup directly\n    markers = L.markerClusterGroup({\n      chunkedLoading: true,\n      chunkInterval: 200,\n      chunkDelay: 50,\n      maxClusterRadius: 80,\n      disableClusteringAtZoom: 16,\n      spiderfyOnMaxZoom: true,\n      animate: true,\n      animateAddingMarkers: true,\n      spiderfyDistanceMultiplier: 1.5,\n      showCoverageOnHover: true,\n      zoomToBoundsOnClick: true,\n      // Configure cluster icon sizes and colors\n      iconCreateFunction: function iconCreateFunction(cluster) {\n        var count = cluster.getChildCount();\n        var size, className;\n\n        // Define size and class based on marker count\n        if (count < 10) {\n          size = 'small';\n        } else if (count < 100) {\n          size = 'medium';\n        } else {\n          size = 'large';\n        }\n\n        // Apply appropriate CSS class\n        className = 'marker-cluster marker-cluster-' + size;\n        return L.divIcon({\n          html: '<div><span>' + count + '</span></div>',\n          className: className,\n          iconSize: L.point(40, 40)\n        });\n      }\n    });\n    console.log('Using MarkerClusterGroup for markers');\n  } catch (e) {\n    console.error('Leaflet.markercluster is not loaded, falling back to normal markers:', e);\n    markers = L.layerGroup();\n  }\n  map.addLayer(markers);\n\n  // Initialize with OpenStreetMap base layer\n  var openStreetMapLayer = L.tileLayer(_constants.tileLayers.openStreetMap.url, _constants.tileLayers.openStreetMap.options);\n  currentLayer = openStreetMapLayer.addTo(map);\n\n  // Setup legend control\n  setupLegend();\n\n  // Setup tile error handling\n  setupTileErrorHandling();\n\n  // Setup map event listeners\n  setupMapEvents();\n  console.timeEnd('Map Initialization');\n  return {\n    map: map,\n    markers: markers,\n    legend: legend\n  };\n}\n\n/**\n * Set up the legend for the map\n */\nfunction setupLegend() {\n  legend = L.control({\n    position: _constants.markerSettings.legendPosition\n  });\n  legend.onAdd = function (map) {\n    var div = L.DomUtil.create('div', 'info legend');\n    div.innerHTML = \"\\n            <div class=\\\"legend-content\\\">\\n                <h4>Location Precision</h4>\\n                <i style=\\\"color: #3694d1;\\\" class=\\\"fa fa-map-marker\\\"></i> Specific Location in Country (e.g., city, facility)<br>\\n                <i style=\\\"color: #e5007d;\\\" class=\\\"fa fa-map-marker\\\"></i> Country Only (no specific location)\\n            </div>\\n        \";\n    return div;\n  };\n}\n\n/**\n * Set up tile error handling to switch between providers if one fails\n */\nfunction setupTileErrorHandling() {\n  currentLayer.on('tileerror', function (error) {\n    console.log('Tile loading error:', error);\n    consecutiveErrors++;\n    if (consecutiveErrors >= maxConsecutiveErrors) {\n      console.log(\"\".concat(maxConsecutiveErrors, \" consecutive errors. Switching tile layer.\"));\n      switchTileLayer();\n      consecutiveErrors = 0;\n    }\n  });\n  currentLayer.on('tileload', function () {\n    consecutiveErrors = 0;\n  });\n}\n\n/**\n * Switch between tile layers when the current one has issues\n */\nfunction switchTileLayer() {\n  map.removeLayer(currentLayer);\n  var openStreetMapLayer = L.tileLayer(_constants.tileLayers.openStreetMap.url, _constants.tileLayers.openStreetMap.options);\n  var stamenTerrainLayer = L.tileLayer(_constants.tileLayers.stamenTerrain.url, _constants.tileLayers.stamenTerrain.options);\n  if (currentLayer._url === _constants.tileLayers.openStreetMap.url) {\n    currentLayer = stamenTerrainLayer.addTo(map);\n    console.log('Switched to Stamen Terrain tiles');\n  } else {\n    currentLayer = openStreetMapLayer.addTo(map);\n    console.log('Switched to OpenStreetMap tiles');\n  }\n}\n\n// Callback for when map move ends\nvar onMoveEnd = exports.onMoveEnd = null;\n\n/**\n * Setup map event listeners\n */\nfunction setupMapEvents() {\n  console.log('Setting up map events');\n  map.on('movestart', function () {\n    map.isMoving = function () {\n      return true;\n    };\n  });\n  map.on('moveend', function () {\n    map.isMoving = function () {\n      return false;\n    };\n    // First check the module-level callback\n    if (typeof onMoveEnd === 'function') {\n      onMoveEnd();\n    }\n    // Then check if we have a global callback as fallback\n    else if (typeof window.updateVisibleData === 'function') {\n      window.updateVisibleData();\n    }\n  });\n}\n\n/**\n * Get marker icon based on location type\n * @param {Boolean} isCountryLevel Whether the location is country-level only\n * @returns {Object} Leaflet divIcon for the marker\n */\nfunction getMarkerIcon(isCountryLevel) {\n  if (isCountryLevel) {\n    return L.divIcon(_constants.markerSettings.countryIcon);\n  }\n  return L.divIcon(_constants.markerSettings.specificIcon);\n}\n\n/**\n * Create a marker with popup for a location\n * @param {Object} location Location data object\n * @returns {Object} Leaflet marker\n */\nfunction createMarker(location) {\n  var icon = getMarkerIcon(location.country_level);\n\n  // Handle potential missing values safely\n  var title = location.Title || 'No Title';\n  var country = location.country || 'Unknown';\n  var url = location.url || '#';\n  var date = location['Date'] || 'Unknown Date';\n  var corruptionCategories = Array.isArray(location['Corruption Categories']) ? String(location['Corruption Categories']).replace(/,(?=[^\\s])/g, ', ') : '';\n  var sectorCategories = Array.isArray(location['Sector Categories']) ? String(location['Sector Categories']).replace(/,(?=[^\\s])/g, ', ') : '';\n\n  // Create email link with subject containing the article title\n  var emailSubject = encodeURIComponent('Inquiry about news article');\n  var emailBody = encodeURIComponent(\"Article: \\\"\".concat(title, \"\\\"\\nCountry: \").concat(country, \"\\nDate: \").concat(date));\n  var emailLink = \"mailto:ti-health@transparency.org?subject=\".concat(emailSubject, \"&body=\").concat(emailBody);\n  return L.marker([location.lat, location.long], {\n    icon: icon\n  }).bindPopup(\"\\n            <div class=\\\"popup-content\\\">\\n                <h3 class=\\\"popup-title\\\">\\\"\".concat(title, \"\\\"</h3>\\n                <div class=\\\"popup-details\\\">\\n                    <p><strong>Country:</strong> \").concat(country, \"</p>\\n                    <p><strong>URL:</strong> \").concat(url !== '#' ? \"<a href=\\\"\".concat(url, \"\\\" target=\\\"_blank\\\">Link</a>\") : 'No URL', \"</p>\\n                    <p><strong>Date:</strong> \").concat(date, \"</p>\\n                    <p><strong>Integrity Area:</strong> \").concat(corruptionCategories, \"</p>\\n                    <p><strong>Sector Area:</strong> \").concat(sectorCategories, \"</p>\\n                    <div style=\\\"margin-top: 5px; text-align: right;\\\">\\n                        <button id=\\\"reporter\\\" title=\\\"Report or request removal of individual articles\\\">\\n                            <a href=\\\"\").concat(emailLink, \"\\\">\\n                                <i class=\\\"fa fa-flag\\\"></i>Report\\n                            </a>\\n                        </button>\\n                    </div>\\n                </div>\\n            </div>\\n        \"));\n}\n\n/**\n * Show or hide the legend based on the country level filter\n * @param {Boolean} showLegend Whether to show the legend\n */\nfunction toggleLegend(showLegend) {\n  if (showLegend && !legendAdded) {\n    legend.addTo(map);\n    legendAdded = true;\n  } else if (!showLegend && legendAdded) {\n    legend.remove();\n    legendAdded = false;\n  }\n}\n\n/**\n * Fit the map view to the marker bounds\n */\nfunction fitMapToBounds() {\n  try {\n    // Try the MarkerClusterGroup getBounds method first\n    var bounds = markers.getBounds();\n    if (bounds.isValid()) {\n      map.fitBounds(bounds, {\n        padding: [30, 30],\n        maxZoom: 12,\n        animate: true,\n        duration: 0.5\n      });\n    }\n  } catch (e) {\n    // Fall back to calculating bounds manually if getBounds doesn't exist\n    try {\n      var layers = markers.getLayers();\n      if (layers && layers.length > 0) {\n        var _bounds = L.latLngBounds();\n        layers.forEach(function (marker) {\n          _bounds.extend(marker.getLatLng());\n        });\n        if (_bounds.isValid()) {\n          map.fitBounds(_bounds, {\n            padding: [30, 30],\n            maxZoom: 12,\n            animate: true,\n            duration: 0.5\n          });\n        }\n      }\n    } catch (e2) {\n      console.error('Error fitting map to bounds:', e2);\n    }\n  }\n}\n\n/**\n * Get the current map bounds\n * @returns {Object} Map bounds\n */\nfunction getMapBounds() {\n  return map.getBounds();\n}\n\n/**\n * Check if map is currently moving\n * @returns {Boolean} Whether map is moving\n */\nfunction isMapMoving() {\n  return map.isMoving ? map.isMoving() : false;\n}\n\n/**\n * Clear all markers from the map\n */\nfunction clearMarkers() {\n  markers.clearLayers();\n}\n\n/**\n * Add markers to the map in chunks to maintain performance\n * @param {Array} markerArray Array of Leaflet markers\n */\nfunction addMarkers(markerArray) {\n  try {\n    // Try the MarkerClusterGroup addLayers method first\n    markers.addLayers(markerArray);\n  } catch (e) {\n    // Fall back to adding markers individually\n    markerArray.forEach(function (marker) {\n      return markers.addLayer(marker);\n    });\n  }\n}\n\n/**\n * Export map module state for external use\n */\nvar _default = exports.default = {\n  initializeMap: initializeMap,\n  getMarkerIcon: getMarkerIcon,\n  createMarker: createMarker,\n  toggleLegend: toggleLegend,\n  fitMapToBounds: fitMapToBounds,\n  getMapBounds: getMapBounds,\n  isMapMoving: isMapMoving,\n  clearMarkers: clearMarkers,\n  addMarkers: addMarkers\n};"},"sourceMaps":null,"error":null,"hash":"a48bb4c14f460b0bc3e9807a5e64b04b","cacheData":{"env":{}}}