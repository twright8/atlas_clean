{"id":"../node_modules/d3-voronoi/src/Cell.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1742042086953},{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-voronoi\\package.json","includedInParent":true,"mtime":1737120276105},{"name":"./Edge","loc":{"line":1,"column":31,"index":31},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-voronoi\\src\\Cell.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-voronoi\\src\\Edge.js"},{"name":"./Diagram","loc":{"line":2,"column":36,"index":78},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-voronoi\\src\\Cell.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-voronoi\\src\\Diagram.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cellHalfedgeEnd = cellHalfedgeEnd;\nexports.cellHalfedgeStart = cellHalfedgeStart;\nexports.clipCells = clipCells;\nexports.createCell = createCell;\nexports.sortCellHalfedges = sortCellHalfedges;\nvar _Edge = require(\"./Edge\");\nvar _Diagram = require(\"./Diagram\");\nfunction createCell(site) {\n  return _Diagram.cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n    va = edge.left,\n    vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\nfunction cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\nfunction cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\nfunction sortCellHalfedges() {\n  for (var i = 0, n = _Diagram.cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = _Diagram.cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n        array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, _Diagram.edges[halfedges[j]]);\n      index.sort(function (i, j) {\n        return array[j] - array[i];\n      });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\nfunction clipCells(x0, y0, x1, y1) {\n  var nCells = _Diagram.cells.length,\n    iCell,\n    cell,\n    site,\n    iHalfedge,\n    halfedges,\n    nHalfedges,\n    start,\n    startX,\n    startY,\n    end,\n    endX,\n    endY,\n    cover = true;\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = _Diagram.cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!_Diagram.edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, _Diagram.edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, _Diagram.edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > _Diagram.epsilon || Math.abs(endY - startY) > _Diagram.epsilon) {\n          halfedges.splice(iHalfedge, 0, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, end, Math.abs(endX - x0) < _Diagram.epsilon && y1 - endY > _Diagram.epsilon ? [x0, Math.abs(startX - x0) < _Diagram.epsilon ? startY : y1] : Math.abs(endY - y1) < _Diagram.epsilon && x1 - endX > _Diagram.epsilon ? [Math.abs(startY - y1) < _Diagram.epsilon ? startX : x1, y1] : Math.abs(endX - x1) < _Diagram.epsilon && endY - y0 > _Diagram.epsilon ? [x1, Math.abs(startX - x1) < _Diagram.epsilon ? startY : y0] : Math.abs(endY - y0) < _Diagram.epsilon && endX - x0 > _Diagram.epsilon ? [Math.abs(startY - y0) < _Diagram.epsilon ? startX : x0, y0] : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx,\n      dy,\n      d2,\n      dc = Infinity;\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = _Diagram.cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n    if (cover) {\n      var v00 = [x0, y0],\n        v01 = [x0, y1],\n        v11 = [x1, y1],\n        v10 = [x1, y0];\n      cover.halfedges.push(_Diagram.edges.push((0, _Edge.createBorderEdge)(site = cover.site, v00, v01)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v01, v11)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v11, v10)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v10, v00)) - 1);\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = _Diagram.cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete _Diagram.cells[iCell];\n      }\n    }\n  }\n}"},"sourceMaps":null,"error":null,"hash":"adb3f680853f2d2c722a68e9f72583a7","cacheData":{"env":{}}}