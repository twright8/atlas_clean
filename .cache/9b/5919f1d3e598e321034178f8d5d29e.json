{"id":"../node_modules/d3-scale/src/continuous.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1741868822789},{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\package.json","includedInParent":true,"mtime":1737120275874},{"name":"d3-array","loc":{"line":1,"column":21,"index":21},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\continuous.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-array\\src\\index.js"},{"name":"d3-interpolate","loc":{"line":2,"column":83,"index":117},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\continuous.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-interpolate\\src\\index.js"},{"name":"./array","loc":{"line":3,"column":25,"index":161},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\continuous.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\array.js"},{"name":"./constant","loc":{"line":4,"column":21,"index":194},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\continuous.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\constant.js"},{"name":"./number","loc":{"line":5,"column":19,"index":228},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\continuous.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-scale\\src\\number.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copy = copy;\nexports.default = continuous;\nexports.identity = identity;\nexports.transformer = transformer;\nvar _d3Array = require(\"d3-array\");\nvar _d3Interpolate = require(\"d3-interpolate\");\nvar _array = require(\"./array\");\nvar _constant = _interopRequireDefault(require(\"./constant\"));\nvar _number = _interopRequireDefault(require(\"./number\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar unit = [0, 1];\nfunction identity(x) {\n  return x;\n}\nfunction normalize(a, b) {\n  return (b -= a = +a) ? function (x) {\n    return (x - a) / b;\n  } : (0, _constant.default)(isNaN(b) ? NaN : 0.5);\n}\nfunction clamper(domain) {\n  var a = domain[0],\n    b = domain[domain.length - 1],\n    t;\n  if (a > b) t = a, a = b, b = t;\n  return function (x) {\n    return Math.max(a, Math.min(b, x));\n  };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0],\n    d1 = domain[1],\n    r0 = range[0],\n    r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function (x) {\n    return r0(d0(x));\n  };\n}\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n    d = new Array(j),\n    r = new Array(j),\n    i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n  return function (x) {\n    var i = (0, _d3Array.bisect)(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\nfunction copy(source, target) {\n  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());\n}\nfunction transformer() {\n  var domain = unit,\n    range = unit,\n    interpolate = _d3Interpolate.interpolate,\n    transform,\n    untransform,\n    unknown,\n    clamp = identity,\n    piecewise,\n    output,\n    input;\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n  scale.invert = function (y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), _d3Interpolate.interpolateNumber)))(y)));\n  };\n  scale.domain = function (_) {\n    return arguments.length ? (domain = _array.map.call(_, _number.default), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n  scale.range = function (_) {\n    return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();\n  };\n  scale.rangeRound = function (_) {\n    return range = _array.slice.call(_), interpolate = _d3Interpolate.interpolateRound, rescale();\n  };\n  scale.clamp = function (_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;\n  };\n  scale.interpolate = function (_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n  scale.unknown = function (_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n  return function (t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}"},"sourceMaps":null,"error":null,"hash":"1c2cc232a71b0d5901565d537e254b81","cacheData":{"env":{}}}