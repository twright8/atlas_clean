{"id":"../node_modules/d3-transition/src/transition/schedule.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1741868822789},{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-transition\\package.json","includedInParent":true,"mtime":1737120276076},{"name":"d3-dispatch","loc":{"line":1,"column":23,"index":23},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-transition\\src\\transition\\schedule.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-dispatch\\src\\index.js"},{"name":"d3-timer","loc":{"line":2,"column":29,"index":68},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-transition\\src\\transition\\schedule.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-timer\\src\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STARTING = exports.STARTED = exports.SCHEDULED = exports.RUNNING = exports.ENDING = exports.ENDED = exports.CREATED = void 0;\nexports.default = _default;\nexports.get = get;\nexports.init = init;\nexports.set = set;\nvar _d3Dispatch = require(\"d3-dispatch\");\nvar _d3Timer = require(\"d3-timer\");\nvar emptyOn = (0, _d3Dispatch.dispatch)(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\nvar CREATED = exports.CREATED = 0;\nvar SCHEDULED = exports.SCHEDULED = 1;\nvar STARTING = exports.STARTING = 2;\nvar STARTED = exports.STARTED = 3;\nvar RUNNING = exports.RUNNING = 4;\nvar ENDING = exports.ENDING = 5;\nvar ENDED = exports.ENDED = 6;\nfunction _default(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index,\n    // For context during callback.\n    group: group,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nfunction init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nfunction set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTED) throw new Error(\"too late; already running\");\n  return schedule;\n}\nfunction get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n    tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = (0, _d3Timer.timer)(schedule, 0, self.time);\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return (0, _d3Timer.timeout)(start);\n\n      // Interrupt the active transition, if any.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions.\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    (0, _d3Timer.timeout)(function () {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n      i = -1,\n      n = tween.length;\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}"},"sourceMaps":null,"error":null,"hash":"67e23e2cce46b8b7a7d5161ccc2b7b67","cacheData":{"env":{}}}