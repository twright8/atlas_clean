{"id":"../node_modules/d3-geo/src/clip/index.js","dependencies":[{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\package.json","includedInParent":true,"mtime":1741868822789},{"name":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\package.json","includedInParent":true,"mtime":1737120275660},{"name":"./buffer.js","loc":{"line":1,"column":23,"index":23},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\index.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\buffer.js"},{"name":"./rejoin.js","loc":{"line":2,"column":23,"index":62},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\index.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\rejoin.js"},{"name":"../math.js","loc":{"line":3,"column":30,"index":108},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\index.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\math.js"},{"name":"../polygonContains.js","loc":{"line":4,"column":28,"index":151},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\index.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\polygonContains.js"},{"name":"d3-array","loc":{"line":5,"column":20,"index":197},"parent":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-geo\\src\\clip\\index.js","resolved":"C:\\Users\\Tom\\PycharmProjects\\health_atlas\\atlas_clean\\node_modules\\d3-array\\src\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _buffer = _interopRequireDefault(require(\"./buffer.js\"));\nvar _rejoin = _interopRequireDefault(require(\"./rejoin.js\"));\nvar _math = require(\"../math.js\");\nvar _polygonContains = _interopRequireDefault(require(\"../polygonContains.js\"));\nvar _d3Array = require(\"d3-array\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _default(pointVisible, clipLine, interpolate, start) {\n  return function (sink) {\n    var line = clipLine(sink),\n      ringBuffer = (0, _buffer.default)(),\n      ringSink = clipLine(ringBuffer),\n      polygonStarted = false,\n      polygon,\n      segments,\n      ring;\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function () {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function () {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = (0, _d3Array.merge)(segments);\n        var startInside = (0, _polygonContains.default)(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          (0, _rejoin.default)(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function () {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(),\n        ringSegments = ringBuffer.result(),\n        i,\n        n = ringSegments.length,\n        m,\n        segment,\n        point;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n    return clip;\n  };\n}\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - _math.halfPi - _math.epsilon : _math.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math.halfPi - _math.epsilon : _math.halfPi - b[1]);\n}"},"sourceMaps":null,"error":null,"hash":"85f577564c2b331009384c8e4d4b5561","cacheData":{"env":{}}}